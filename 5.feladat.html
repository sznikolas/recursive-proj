<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mgr munka</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="styles/osszes.css">
    <link rel="stylesheet" href="styles/4.feladat.css">


</head>
<body>
    <div class="bigContainer">
 
        <div class="box02">

    <h1>Szúdoku - Sudoku</h1>

    <div class="smallContainer"><br>
    <p><b>Feladat leírása:</b> A sudoku egy 9x9-es mátrix, amely 1-től 9-ig terjedő számokkal van kitöltve oly módon, 
        hogy minden sorban, oszlopban és almátrixban (3x3) minden egyes számjegy 1-től 9-ig szerepel. Kapunk egy részben 
        kitöltött 9x9-es mátrixot, és minden megmaradt cellát ki kell töltenünk benne.</p>
<br>
</div>

<div class="smallContainer">
    <button onclick="location.href='index.html'" type="button" class="example_b" >feladatok</button>
    
<!-- Button trigger modal -->
<div class="container3">
<button type="button" class="example_b"  data-toggle="modal" data-target="#exampleModalScrollable">
    C kód</button>
  
  <!-- Modal -->
  <div class="modal fade" id="exampleModalScrollable" tabindex="-1" role="dialog" aria-labelledby="exampleModalScrollableTitle" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="exampleModalScrollableTitle">Szúdoku megoldása C nyelvben</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
            <pre class="line-numbers">
                <code class="language-clike">
//<b>C program a Szúdoku megoldására</b>

#include &lt;stdio.h&gt;

#define SIZE 9

//<b>Sudoku probléma</b>
int matrix[9][9] = {
    {6,5,0,8,7,3,0,9,0},
    {0,0,3,2,5,0,0,0,8},
    {9,8,0,1,0,4,3,5,7},
    {1,0,5,0,0,0,0,0,0},
    {4,0,0,0,0,0,0,0,2},
    {0,0,0,0,0,0,5,0,3},
    {5,7,8,3,0,1,0,2,6},
    {2,0,0,0,4,8,9,0,0},
    {0,9,0,6,2,5,0,8,1}
};

//<b>Függvény a sudoku kiíratására</b>
void print_sudoku()
{
    int i,j;
    for(i=0;i&lt;SIZE;i++)
    {
        for(j=0;j&lt;SIZE;j++)
        {
            printf("%d\t",matrix[i][j]);
        }
        printf("\n\n");
    }
}


/*<b>funkció annak ellenőrzésére, hogy minden cella ki van-e jelölve vagy sem.
Ha van nem hozzárendelt cella, akkor ez a függvény megváltoztatja a cellák értékeit
(sorok és oszlopok értékeit) ennek megfelelően</b>*/
int number_unassigned(int *row, int *col)
{
    int num_unassign = 0;
    int i,j;
    for(i=0;i&lt;SIZE;i++)
    {
        for(j=0;j&lt;SIZE;j++)
        {
            //<b>a cella nem hozzárendelt</b>
            if(matrix[i][j] == 0)
            {
                //<b>a sorok és oszlopok értékek megváltoztatása</b>
                *row = i;
                *col = j;
                //<b>létezik egy vagy több nem hozzárendelt cella</b>
                num_unassign = 1;
                return num_unassign;
            }
        }
    }
    return num_unassign;
}

/*<b>funkció, amely ellenőrzi, hogy tudunk-e tenni
egy értéket egy adott cellába vagy sem</b>*/
int is_safe(int n, int r, int c)
{
    int i,j;
    //<b>sorok ellenőrzése</b>
    for(i=0;i&lt;SIZE;i++)
    {
        //<b>van egy cella ugyanazzal az értékkel</b>
        if(matrix[r][i] == n)
            return 0;
    }
    //<b>oszlopok ellenőrzése</b>
    for(i=0;i&lt;SIZE;i++)
    {
        //<b>van egy cella, amelynek értéke egyenlő i-vel</b>
        if(matrix[i][c] == n)
            return 0;
    }
    //<b>almátrix ellenőrzése</b>
    int row_start = (r/3)*3;
    int col_start = (c/3)*3;
    for(i=row_start;i&lt;row_start+3;i++)
    {
        for(j=col_start;j&lt;col_start+3;j++)
        {
            if(matrix[i][j]==n)
                return 0;
        }
    }
    return 1;
}

//<b>függvény a sudoku megoldásához backtracking használatával</b>
int solve_sudoku()
{
    int row;
    int col;
    //<b>ha minden cellát kiosztottunk, akkor a sudoku már megoldódott és</b>
    //<b>hivatkozással adjuk át, mert a number_unassigned megváltoztatja a sor és az oszlop értékét.</b>
    if(number_unassigned(&amp;row, &amp;col) == 0)
        return 1;
    int n,i;
    //<b>1 és 9 közötti szám</b>
    for(i=1;i&lt;=SIZE;i++)
    {
        //<b>hozzárendelhetjük i-t a cellához vagy sem</b>
        //<b>a cella mátrix[row][col]</b>
        if(is_safe(i, row, col))
        {
            matrix[row][col] = i;
            //<b>backtracking</b>
            if(solve_sudoku())
                return 1;
            //<b>ha nem tudunk ezzel a megoldással haladni rendezzük át a cellát</b>
            matrix[row][col]=0;
        }
    }
    return 0;
}

int main()
{
    if (solve_sudoku())
        print_sudoku();
    else
        printf("Nincs megoldás\n");
    return 0;
}
<br>
<a href="https://www.codesdope.com/blog/article/solving-sudoku-with-backtracking-c-java-and-python/" target="_blank">Forrás</a>
                </code>
             </pre>
        </div>
      </div>
    </div>
  </div>
</div><!-- container3 -->
  
<div class="container3">
    <canvas id="canvas5" style="background: url(images/nemtudom.png)"></canvas>
    </div>

    <div class="container3">
        <input id="stepFrwd" type="submit" class="example_b" name="button" value="előrelépés"/>
        <!-- <input id="stepPrev" type="submit" class="example_b" name="button" value="visszalépés"/> -->
        <input id="startAnim" type="submit" class="example_b" name="button" value="start"/>
        <input id="resetAnim" type="submit" class="example_b" name="button" value="reset"/>
        <div class="example_b">
            <input type="range" min="1" max="10" value="3" class="slider" id="myRange">
          </div>
        </div>
        
        <div class="container3">
        <p> <output id="proba1">Lépések:</output>
         <label id="label1">1. lépés: előre</label></p>
        </div>
</div>


<div class="smallContainer"><br>
    <details>
       <summary>
            
    <b>A kód magyarázata</b><br><br>
        </summary>
        <p>
            Kezdetben csak egy mátrixot készítünk a Sudoku számára, és a ki nem osztott celláit 0-val töltjük fel. 
            Így a mátrix tartalmazza a Sudoku feladatot, és a 0 értékű cellák üres cellák.<br><br>
            <b>print_sudoku()</b> → Ez csak egy függvény a mátrix kiíratására.<br><br>
            <b>number_unassigned</b> → Ez a függvény megkeres egy üres cellát, és a 'row' és 'col' változókat az adott cella indexeivel teszi egyenlővé. 
            C-ben mutatókat használtunk az ehhez a függvényhez átadott változók (row, col) értékének megváltoztatására (pass by reference). 
            Tehát ez a függvény megmondja nekünk, hogy van-e ki nem osztott cella vagy nincs. És ha van ki nem osztott cella, 
            akkor ez a függvény megadja a cella indexeit is.<br><br>
            <b>is_safe(int n, int r, int c)</b> → Ez a függvény ellenőrzi, hogy az 'n' értéket betehetjük-e az (r, c) cellába vagy sem. 
            Ezt úgy tesszük, hogy először azt ellenőrizzük, hogy az 'r' sorban van-e olyan cella, amelynek értéke 'n' vagy sem - if(mátrix[r][i] == n). 
            Ezután ellenőrizzük, hogy a 'c' oszlopban van-e 'n' értékű cella vagy sem - if(mátrix[i][c] == n). 
            Végül pedig ellenőrizzük az almátrixot. (r/3)*3 megadja az r sor kezdőindexét. Például, ha az 'r' értéke 2, akkor az almátrixban van, 
            amely a (0, 0)-tól kezdődik. Hasonlóképpen, a kezdő oszlop értékét (c/3)*3 segítségével kapjuk meg. Így ha egy cella értéke (2,2), 
            akkor ez a cella egy olyan almátrixban lesz, amely (0,0)-ból indul, és ezt az értéket (c/3)*3 és (r/3)*3 segítségével kapjuk meg. 
            Miután megkaptuk a kezdőindexeket, könnyedén végig tudunk iterálni az almátrixon, hogy ellenőrizzük, hogy az "n" értéket elhelyezhetjük-e 
            az almátrixban vagy sem.<br><br>
            <b>solve_sudoku()</b> → Ez a tényleges függvény, amely megoldja a Sudokut, és visszalépést(backtracking) használ. Először a number_unassigned függvény 
            segítségével ellenőrizzük, hogy van-e ki nem rendelt cella, és ha nincs ki nem rendelt cella, akkor a Sudoku megoldódott. 
            number_unassigned függvény megadja az üres cellák indexeit is. Így ha van üres cella, akkor megpróbáljuk kitölteni ezt a cellát egy 
            1 és 9 közötti értékkel. Az is_safe segítségével pedig ellenőrizni fogjuk, hogy egy adott értéket be tudunk-e tölteni az adott cellába vagy sem. 
            Miután megtaláltuk az értéket, megpróbáljuk megoldani a Sudoku többi részét -> solve_sudoku. Ha ezzel az értékkel nem sikerül megoldani a többit, 
            akkor visszatérünk, és megpróbálunk egy másik értéket erre a cellára mátrix[row][col]=0;. A ciklus megpróbálja a cella más értékeit is. 
        </p>
    <br>
    </details>
    </div>

    </div>
</div>
    <script src="javaScript/5.feladat.js"></script>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

</body>
</html>