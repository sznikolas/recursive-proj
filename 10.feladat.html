<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mgr munka</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
    <link rel="stylesheet" href="styles/osszes.css">
    


</head>
<body>
    <div class="bigContainer">
 
        <div class="box02">

    <h1>Szúdoku - Sudoku</h1>

    <div class="smallContainer"><br>
    <p><b>Feladat:</b> Írjon programot C nyelven a szúdoku logikai játék megoldására, ami figyelembe veszi a játékszabályokat. A program megoldásához használjunk rekurziót.</p>
<br>
</div>

<div class="smallContainer"><br>
    <details>
       <summary>
            
    <b>Szúdoku</b><br><br>
        </summary>
    <p>    
        <b>Szúdoku</b><br><br>
        &emsp;&emsp;A sudoku egy 9x9-es mátrix, amely 1-től 9-ig terjedő számokkal van kitöltve oly módon, 
        hogy minden sorban, oszlopban és almátrixban (3x3) minden egyes számjegy 1-től 9-ig szerepel. Kapunk egy részben 
        kitöltött 9x9-es mátrixot, és minden megmaradt cellát ki kell töltenünk benne. 
        Ha egy szám kétszer szerepel ugyanabban az oszlopban, sorban, vagy almátrixban, akkor a tábla kitöltése helytelen.
        <br><br>
        &emsp;&emsp;A szúdoku legáltalánosabb változata egy 9x9-es táblázat, ami 9 darab 3x3-as altáblázatból áll. 
        A táblázatot úgy kell kitöltenünk, hogy minden sorban, oszlopban és altáblában az 1-9 számok mindegyike pontosan egyszer forduljon elő. 
        A megoldhatóság kedvéért a táblázat készítője általában előre kitölt pár cellát, hogy csak egy megoldás létezzen. 
        A szúdokunak több fajtája is létezik, mi a legismertebbet használtuk.<br><br>

        &emsp;&emsp;Az alábbiakban egy 9x9-es szúdokut láthatunk, amiben vannak már kitöltött cellák és ezen mutatjuk be a logikai játék rekurzív megoldását.

    </p> 
<br>
</details>

</div>

<div class="smallContainer">
    <button onclick="location.href='index.html'" type="button" class="example_b" >feladatok</button>
    
<!-- Button trigger modal -->
<div class="container3">
<button type="button" class="example_b"  data-toggle="modal" data-target="#exampleModalScrollable">
    C kód</button>
  
  <!-- Modal -->
  <div class="modal fade" id="exampleModalScrollable" tabindex="-1" role="dialog" aria-labelledby="exampleModalScrollableTitle" aria-hidden="true">
    <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="exampleModalScrollableTitle">Szúdoku megoldása C nyelvben</h5>
          <button type="button" class="close" data-dismiss="modal" aria-label="Close">
            <span aria-hidden="true">&times;</span>
          </button>
        </div>
        <div class="modal-body">
            <pre class="line-numbers">
                <code class="language-clike">
//<b>C program a Szúdoku megoldására</b>

#include &lt;stdio.h&gt;

#define SIZE 9

//<b>Szúdoku probléma</b>
int matrix[9][9] = {
    {0,6,0,0,0,2,0,0,5},
    {0,0,0,6,8,0,0,1,0},
    {1,0,7,0,0,0,0,0,0},
    {0,0,0,0,0,1,0,0,3},
    {9,0,2,0,5,0,8,0,7},
    {4,0,0,2,0,0,0,0,0},
    {0,0,0,0,0,0,5,0,2},
    {0,5,0,0,4,6,0,0,0},
    {8,0,0,3,0,0,0,9,0}
};

//<b>Függvény a sudoku kiíratására</b>
void print_sudoku()
{
    int i,j;
    for(i=0;i&lt;SIZE;i++)
    {
        for(j=0;j&lt;SIZE;j++)
        {
            printf("%d\t",matrix[i][j]);
        }
        printf("\n\n");
    }
}


/*<b>Függvény annak ellenőrzésére, hogy minden cellához van-e hozzárendelve érték vagy sem.
Ha van üres cella, akkor ez a függvény megváltoztatja a cellák értékeit
(sorok és oszlopok értékeit) ennek megfelelően</b>*/
int number_unassigned(int *row, int *col)
{
    int num_unassign = 0;
    int i,j;
    for(i=0;i&lt;SIZE;i++)
    {
        for(j=0;j&lt;SIZE;j++)
        {
            //<b>ha a cellához nincs érték hozzárendelve</b>
            if(matrix[i][j] == 0)
            {
                //<b>a sorok és oszlopok értékeinek megváltoztatása</b>
                *row = i;
                *col = j;
                //<b>létezik egy vagy több nem hozzárendelt értékű cella</b>
                num_unassign = 1;
                return num_unassign;
            }
        }
    }
    return num_unassign;
}

/*<b>függvény, amely ellenőrzi, hogy hozzá tudunk-e rendelni
egy értéket biztonságosan egy adott cellához vagy sem</b>*/
int is_safe(int n, int r, int c)
{
    int i,j;
    //<b>sorok ellenőrzése</b>
    for(i=0;i&lt;SIZE;i++)
    {
        //<b>van egy cella ugyanazzal az értékkel</b>
        if(matrix[r][i] == n)
            return 0;
    }
    //<b>oszlopok ellenőrzése</b>
    for(i=0;i&lt;SIZE;i++)
    {
        //<b>ha van egy cella, amelynek értéke egyenlő i-vel</b>
        if(matrix[i][c] == n)
            return 0;
    }
    //<b>almátrix ellenőrzése</b>
    int row_start = (r/3)*3;
    int col_start = (c/3)*3;
    for(i=row_start;i&lt;row_start+3;i++)
    {
        for(j=col_start;j&lt;col_start+3;j++)
        {
            if(matrix[i][j]==n)
                return 0;
        }
    }
    return 1;
}

//<b>függvény a sudoku megoldásához backtracking használatával</b>
int solve_sudoku()
{
    int row;
    int col;
    //<b>ha minden cellának van értéke, akkor a sudoku már megoldódott</b>
    /*<b>referenciakénti paraméterátadás -> a number_unassigned 
        megváltoztatja a sor és az oszlop (cella) értékét</b>*/
    if(number_unassigned(&amp;row, &amp;col) == 0)
        return 1;
    int n,i;
    //<b>1 és 9 közötti szám</b>
    for(i=1;i&lt;=SIZE;i++)
    {
        //<b>hozzárendelhetjük-e i értéket a cellához vagy sem</b>
        //<b>a cella a mátrix[sor][oszlop]-al van megadva</b>
        if(is_safe(i, row, col))
        {
            matrix[row][col] = i;
            //<b>backtracking</b>
            if(solve_sudoku())
                return 1;
            //<b>ha nem tudunk ezzel az értékkel haladni, rendezzük át a cellaértékeket</b>
            matrix[row][col]=0;
        }
    }
    return 0;
}

int main()
{
    if (solve_sudoku())
        print_sudoku();
    else
        printf("Nincs megoldás\n");
    return 0;
}
<br>
<a href="https://www.codesdope.com/blog/article/solving-sudoku-with-backtracking-c-java-and-python/" target="_blank">Forrás</a>
                </code>
             </pre>
        </div>
      </div>
    </div>
  </div>
</div><!-- container3 -->
  
<div class="container3">
    <canvas id="canvas" style="background: url(images/sudokus.png)"></canvas>
    </div>

    <output class="lepesek" style="display: block; width:100%; height:30px; text-align:center;"> 
        <label id="label1" class="lepesekLeirasa">oldjuk meg</label></output> 

    <div class="container3">
        <div id="buttons">
        <input id="stepFrwd" type="submit" class="example_b" name="button" value="előrelépés"/>
        <!-- <input id="stepPrev" type="submit" class="example_b" name="button" value="visszalépés"/> -->
        <input id="startAnim" type="submit" class="example_b" name="button" value="start"/>
        <input id="resetAnim" type="submit" class="example_b" name="button" value="reset"/>
        <div class="example_b">
            <input type="range" min="1" max="10" value="3" class="slider" id="myRange">
          </div>
        </div>
    </div>

    <ul>  
        <li>A visszalépés(backtracking) során először egy részmegoldással kezdünk, és ha ez a részmegoldás nem ad helyes végső választ, 
        akkor egyszerűen visszatérünk és megváltoztatjuk a részmegoldásunk értékét. 
        Hasonló módon fogjuk megoldani a Szúdokut is:</li>
        <li>Ha nincsenek üres cellák, akkor a Szúdoku már meg van oldva. Ekkor egyszerűen true-t adunk vissza.</li>
        <li>Ellenkező esetben az első üres cellát feltöltsük egy 1 és 9 közötti számjeggyel, 
        úgy, hogy ne legyen konfliktus egyik sorban, oszlopban vagy a 3x3-as almátrixban sem.</li>
        <li>Ezután megpróbáljuk kitölteni a többi üres cellát is, 
            és ha ez sikeresen megtörténik, akkor true-t adunk vissza.</li>
        <li> Ellenkező esetben visszatérünk(backtrack), és megváltoztatjuk azt a számjegyet, 
            amellyel az előző cellát kitöltöttük és újra megpróbáljuk kitölteni a következő üres cellákat.
            Ha nincs olyan számjegy, amelyik megfelelne az igénynek, akkor egyszerűen false-t adunk vissza, mivel nincs megoldása ennek a Szúdokunak.</li>  
        </ul> 
    <br>
        
        
</div>


<div class="smallContainer"><br>
    <details>
       <summary>
            
    <b>Az algoritmus leírása</b><br><br>
        </summary>
        <p>
            Kezdetben csak egy mátrixot készítünk a Sudoku számára, és a ki nem osztott celláit 0-val töltjük fel. 
            Így a mátrix tartalmazza a Szúdoku feladatot, és a 0 értékű cellák az üres cellák, amikhez még nincsenek értékek rendelve.<br><br>
            <b>print_sudoku()</b> → Ez csak egy függvény a mátrix kiíratására.<br><br>
            <b>number_unassigned</b> → Ez a függvény megkeres egy üres cellát, és a 'row' és 'col' változókat az adott cella indexeivel teszi egyenlővé.<br> 
            &emsp;Ebben a C programban pointereket használtunk az ehhez a függvényhez átadott változók (row, col) értékének megváltoztatására (referenciakénti paraméterátadás). 
            Tehát ez a függvény megmondja nekünk, hogy van-e olyan cella, amihez még nincs érték rendelve, vagy nincs. És ha van ki nem osztott cella, 
            akkor ez a függvény megadja a cella indexeit is.<br><br>
            <b>is_safe(int n, int r, int c)</b> → Ez a függvény ellenőrzi, hogy az 'n' értéket betehetjük-e az (r, c) cellába vagy sem. 
            Ezt úgy tesszük, hogy először azt ellenőrizzük, hogy az 'r' sorban van-e olyan cella, amelynek értéke 'n' vagy sem - <b>if(matrix[r][i] == n)</b>.<br> 
            
            &emsp;Ezután ellenőrizzük, hogy a 'c' oszlopban van-e 'n' értékű cella vagy sem - <b>if(matrix[i][c] == n)</b>.<br> 
            
            &emsp;Végül pedig ellenőrizzük az almátrixot. <b>(r/3)*3</b> megadja az r sor kezdőindexét. Például, ha az 'r' értéke 2, akkor abban az almátrixban van, 
            amely a (0, 0)-tól kezdődik.<br> 
            &emsp;Hasonlóképpen, a kezdő oszlop értékét <b>(c/3)*3</b> segítségével kapjuk meg. Így ha egy cella értéke (2,2), 
            akkor ez a cella egy olyan almátrixban lesz, amely (0,0)-ból indul, és ezt az értéket <b>(c/3)*3</b> és <b>(r/3)*3</b> segítségével kapjuk meg.<br> 
            
            &emsp;Miután megkaptuk a kezdőindexeket, könnyedén végig tudunk iterálni az almátrixon, hogy ellenőrizzük, hogy az "n" értéket elhelyezhetjük-e 
            az almátrixban vagy sem.<br><br>

            <b>solve_sudoku()</b> → Ez a tényleges függvény, amely megoldja a Szúdokut, és visszalépést(backtracking) használ.<br> 
            &emsp;Először a number_unassigned függvény 
            segítségével ellenőrizzük, hogy van-e üres cella, és ha nincs üres cella, akkor a Szúdoku megoldódott.<br> 
            &emsp;<b>number_unassigned</b> függvény megadja az üres cellák indexeit is. Így ha van üres cella, akkor megpróbáljuk kitölteni ezt a cellát egy 
            1 és 9 közötti értékkel.<br> 
            &emsp;Az <b>is_safe</b> függvény segítségével pedig ellenőrizni tudjuk, hogy egy adott értéket be tudunk-e tölteni az adott cellába vagy sem. 
            Miután megtaláltuk az értéket, megpróbáljuk megoldani a Szúdoku többi részét is a <b>solve_sudoku</b> függvénnyel rekurzívan. Ha ezzel az értékkel nem sikerül megoldani a többit, 
            akkor visszatérünk, és megpróbálunk egy másik értéket erre a cellára <b>mátrix[row][col]=0;</b>. A ciklus megpróbálja a cellát más értékekkel is. 
        </p>
    <br>
    </details>
    </div>

    </div>
</div>
    <script src="javaScript/10.feladat.js"></script>

    <script src="https://code.jquery.com/jquery-3.3.1.slim.min.js" integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js" integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>

</body>
</html>